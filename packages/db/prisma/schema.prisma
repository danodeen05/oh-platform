// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==========================================
// TENANT & MULTI-TENANCY
// ==========================================

model Tenant {
  id            String   @id @default(cuid())
  slug          String   @unique
  brandName     String
  logoUrl       String?
  primaryColor  String   @default("#667eea")
  domain        String?
  
  stripeAccountId      String?
  subscriptionStatus   SubscriptionStatus @default(TRIAL)
  subscriptionTier     String             @default("starter")
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  locations     Location[]
  menuItems     MenuItem[]
  orders        Order[]
  users         TenantUser[]
  transactions  PlatformTransaction[]
}

enum SubscriptionStatus {
  TRIAL
  ACTIVE
  PAST_DUE
  CANCELLED
  SUSPENDED
}

model TenantUser {
  id        String     @id @default(cuid())
  tenantId  String
  tenant    Tenant     @relation(fields: [tenantId], references: [id])
  
  email     String
  role      TenantRole @default(STAFF)
  
  createdAt DateTime   @default(now())
  
  @@unique([tenantId, email])
}

enum TenantRole {
  OWNER
  ADMIN
  MANAGER
  STAFF
}

// ==========================================
// LOCATIONS
// ==========================================

model Location {
  id        String   @id @default(cuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id])

  name      String
  city      String
  address   String
  lat       Float
  lng       Float

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  seats      Seat[]
  orders     Order[]
  stats      LocationStats?
  waitQueue  WaitQueue[]
}

model LocationStats {
  id              String   @id @default(cuid())
  locationId      String   @unique
  location        Location @relation(fields: [locationId], references: [id])
  
  totalSeats      Int      @default(0)
  availableSeats  Int      @default(0)
  occupiedSeats   Int      @default(0)
  avgWaitMinutes  Int      @default(0)
  
  updatedAt       DateTime @updatedAt
}

// ==========================================
// MENU
// ==========================================

model MenuItem {
  id         String   @id @default(cuid())
  tenantId   String
  tenant     Tenant   @relation(fields: [tenantId], references: [id])

  name       String

  // Flexible pricing system
  basePriceCents      Int      // Base price (can be $0 for included items)
  additionalPriceCents Int     @default(0) // Price for extra servings
  includedQuantity    Int      @default(0) // Number of servings included (1 for baby bok choy, 0 for others)

  category   String?  // e.g., "protein", "vegetables", "noodles", "main01", "slider01", etc.
  description String?
  isAvailable Boolean  @default(true)

  // Enhanced menu organization
  categoryType     CategoryType?  // Type of category (MAIN, SLIDER, ADDON, etc.)
  selectionMode    SelectionMode  @default(MULTIPLE) // How users select this item
  displayOrder     Int            @default(0) // Sort order within category
  sliderConfig     Json?          // Slider metadata: {min, max, default, labels, step}

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  orderItems OrderItem[]
}

enum CategoryType {
  MAIN
  SLIDER
  ADDON
  SIDE
  DRINK
  DESSERT
}

enum SelectionMode {
  SINGLE      // Only one selection allowed (main01, main02)
  MULTIPLE    // Multiple selections allowed (add-ons, sides, drinks)
  SLIDER      // Slider control with levels (slider01-08)
  INCLUDED    // Automatically included, can't be removed
}

// ==========================================
// SEATING
// ==========================================

model Seat {
  id         String     @id @default(cuid())
  locationId String
  location   Location   @relation(fields: [locationId], references: [id])

  number     String     // Pod number (e.g., "01", "02", "03")
  qrCode     String     @unique // QR code for pod verification
  status     SeatStatus @default(AVAILABLE)

  // Position in the seating layout (for visual map)
  // U-shape: left side (entrance), bottom, right side (exit)
  row        Int        @default(0)  // 0=left, 1=bottom, 2=right
  col        Int        @default(0)  // Position within the row
  side       String     @default("left") // "left", "bottom", "right" for U-shape

  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  orders     Order[]

  @@unique([locationId, number]) // Ensure unique pod numbers per location
}

enum SeatStatus {
  AVAILABLE
  OCCUPIED
  RESERVED
  CLEANING
}

// ==========================================
// ORDERS
// ==========================================

model Order {
  id              String      @id @default(cuid())
  orderNumber     String      @unique // Long unique ID (e.g., "ORD-1764819716365-MI9K2P")
  kitchenOrderNumber String?  // Daily sequential number (e.g., "0001", "0002")
  orderQrCode     String?     @unique // QR code for customer to scan at kiosk and pod
  status          OrderStatus @default(PENDING_PAYMENT)

  totalCents      Int
  items           OrderItem[]
  customizations  Json?

  fulfillmentType FulfillmentType @default(DINE_IN)
  estimatedArrival DateTime?

  // Lifecycle timestamps
  paidAt          DateTime?    // When payment succeeded
  arrivedAt       DateTime?    // When scanned at kiosk (check-in)
  queuedAt        DateTime?    // When entered queue (if waiting for pod)
  prepStartTime   DateTime?    // When kitchen started cooking
  readyTime       DateTime?    // When food finished cooking
  deliveredAt     DateTime?    // When food brought to table
  completedTime   DateTime?    // When customer finished
  podCleanedAt    DateTime?    // When pod was cleaned after customer left

  // Pod/Seat Assignment
  seatId          String?
  seat            Seat?        @relation(fields: [seatId], references: [id])
  podAssignedAt   DateTime?    // When pod was assigned
  podConfirmedAt  DateTime?    // When customer scanned QR to confirm pod
  podReservationExpiry DateTime? // When reservation expires if not confirmed
  podSelectionMethod String?   // "AUTO" | "CUSTOMER_SELECTED" | "STAFF_ASSIGNED"
  podReleasedAt   DateTime?    // When pod reservation was auto-released due to no-show
  podReleasedNumber String?    // Which pod was released (for notification display)

  // Queue Management
  queuePosition   Int?         // Current position in queue
  estimatedWaitMinutes Int?    // Estimated wait time
  arrivalDeviation Int?        // Minutes early/late vs estimatedArrival

  // Notification tracking
  notifiedAt      DateTime?    // When customer was notified of pod assignment
  notificationMethod String?   // "PUSH" | "SMS" | "EMAIL"

  locationId      String?
  location        Location?    @relation(fields: [locationId], references: [id])
  tenantId        String
  tenant          Tenant       @relation(fields: [tenantId], references: [id])

  userId          String?
  user            User?        @relation(fields: [userId], references: [id])

  paymentStatus   PaymentStatus @default(PENDING)
  stripePaymentId String?

  // Child orders (add-ons placed after initial order)
  parentOrderId   String?
  parentOrder     Order?       @relation("OrderAddOns", fields: [parentOrderId], references: [id])
  childOrders     Order[]      @relation("OrderAddOns")

  creditEvents    CreditEvent[]
  waitQueueEntry  WaitQueue?

  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
}

enum OrderStatus {
  PENDING_PAYMENT
  PAID
  QUEUED
  PREPPING
  READY
  SERVING      // Food delivered to table, customer eating
  COMPLETED
  CANCELLED
}

enum FulfillmentType {
  DINE_IN     // Default - customer orders and dines in pod
  PRE_ORDER   // Order placed before arrival (legacy)
  WALK_IN     // Order placed at location (legacy)
  PICKUP      // Pickup order (future feature)
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

model OrderItem {
  id         String    @id @default(cuid())
  orderId    String
  order      Order     @relation(fields: [orderId], references: [id])

  menuItemId String
  menuItem   MenuItem  @relation(fields: [menuItemId], references: [id])

  quantity   Int
  priceCents Int

  // For slider items, store the display label (e.g., "Light", "Medium", "Rich")
  selectedValue String?

  createdAt  DateTime  @default(now())
}

// ==========================================
// USERS & REFERRALS
// ==========================================

model User {
  id            String   @id @default(cuid())
  email         String?  @unique
  phone         String?  @unique
  name          String?

  // Referral system
  referralCode  String   @unique @default(cuid())
  referredById  String?
  referredBy    User?    @relation("Referrals", fields: [referredById], references: [id])
  referrals     User[]   @relation("Referrals")

  creditsCents  Int      @default(0)

  // Membership tier system
  membershipTier      MembershipTier @default(CHOPSTICK)
  tierProgressOrders  Int            @default(0)
  tierProgressReferrals Int          @default(0)
  lifetimeOrderCount  Int            @default(0)
  lifetimeSpentCents  Int            @default(0)
  currentStreak       Int            @default(0)
  longestStreak       Int            @default(0)
  lastOrderDate       DateTime?

  // Arrival prediction metrics (for queue prioritization)
  avgArrivalDeviation Float?        // Average minutes early/late
  arrivalAccuracy     Float?        // 0-1 score of on-time arrivals
  onTimeArrivals      Int            @default(0)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  orders         Order[]
  creditEvents   CreditEvent[]
  pendingCredits PendingCredit[]
  badges         UserBadge[]
  challenges     UserChallenge[]
}

enum MembershipTier {
  CHOPSTICK
  NOODLE_MASTER
  BEEF_BOSS
}

model CreditEvent {
  id            String   @id @default(cuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id])
  
  type          CreditEventType
  amountCents   Int
  
  orderId       String?
  order         Order?   @relation(fields: [orderId], references: [id])
  
  description   String?
  metadata      Json?
  
  createdAt     DateTime @default(now())
}

enum CreditEventType {
  REFERRAL_SIGNUP
  REFERRAL_ORDER
  REFERRAL_ORDER_PENDING  // Credit queued for next disbursement
  CASHBACK
  CREDIT_APPLIED
  CREDIT_EXPIRED
  ADMIN_ADJUSTMENT
}

// ==========================================
// PENDING CREDITS (Scheduled Disbursement)
// ==========================================

model PendingCredit {
  id            String   @id @default(cuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id])

  type          PendingCreditType
  amountCents   Int

  // Reference to what triggered this credit
  sourceUserId  String?  // The referred user who placed the order
  sourceOrderId String?  // The order that triggered this credit

  description   String?

  // Scheduling
  scheduledFor  DateTime // Next disbursement date (1st or 16th)
  disbursedAt   DateTime?

  createdAt     DateTime @default(now())
}

enum PendingCreditType {
  REFERRAL_ORDER  // Credit from referred friend's first order
}

// ==========================================
// GAMIFICATION
// ==========================================

model Badge {
  id          String   @id @default(cuid())
  slug        String   @unique
  name        String
  description String
  iconEmoji   String
  category    BadgeCategory
  isActive    Boolean  @default(true)
  
  createdAt   DateTime @default(now())
  
  userBadges  UserBadge[]
}

enum BadgeCategory {
  MILESTONE
  CHALLENGE
  REFERRAL
  SPECIAL
  STREAK
}

model UserBadge {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  badgeId   String
  badge     Badge    @relation(fields: [badgeId], references: [id])
  
  earnedAt  DateTime @default(now())
  
  @@unique([userId, badgeId])
}

model Challenge {
  id            String   @id @default(cuid())
  slug          String   @unique
  name          String
  description   String
  rewardCents   Int
  iconEmoji     String
  
  requirements  Json
  
  startsAt      DateTime?
  endsAt        DateTime?
  isActive      Boolean  @default(true)
  
  createdAt     DateTime @default(now())
  
  userChallenges UserChallenge[]
}

model UserChallenge {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  challengeId String
  challenge   Challenge @relation(fields: [challengeId], references: [id])
  
  progress    Json
  completedAt DateTime?
  rewardClaimed Boolean @default(false)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([userId, challengeId])
}

// ==========================================
// WAIT QUEUE
// ==========================================

model WaitQueue {
  id              String      @id @default(cuid())
  orderId         String      @unique
  order           Order       @relation(fields: [orderId], references: [id])
  locationId      String
  location        Location    @relation(fields: [locationId], references: [id])

  arrivedAt       DateTime    // Actual arrival at kiosk
  estimatedArrival DateTime?  // What customer selected when ordering
  priority        Int         // Calculated priority score
  status          QueueStatus @default(WAITING)

  assignedAt      DateTime?   // When pod assigned
  expiredAt       DateTime?   // If no-show or cancelled

  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  @@index([locationId, status, priority])
}

enum QueueStatus {
  WAITING         // In queue, no pod yet
  ASSIGNED        // Pod assigned, heading there
  CONFIRMED       // At pod, confirmed
  EXPIRED         // No-show or cancelled
}

// ==========================================
// PLATFORM REVENUE
// ==========================================

model PlatformTransaction {
  id              String          @id @default(cuid())
  tenantId        String
  tenant          Tenant          @relation(fields: [tenantId], references: [id])

  type            TransactionType
  amountCents     Int
  platformFeeCents Int
  tenantNetCents  Int

  metadata        Json?

  createdAt       DateTime        @default(now())
}

enum TransactionType {
  ORDER
  SUBSCRIPTION
  REFUND
}
