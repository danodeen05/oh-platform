// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==========================================
// TENANT & MULTI-TENANCY
// ==========================================

model Tenant {
  id           String  @id @default(cuid())
  slug         String  @unique
  brandName    String
  logoUrl      String?
  primaryColor String  @default("#667eea")
  domain       String?

  stripeAccountId    String?
  subscriptionStatus SubscriptionStatus @default(TRIAL)
  subscriptionTier   String             @default("starter")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  locations    Location[]
  menuItems    MenuItem[]
  orders       Order[]
  users        TenantUser[]
  transactions PlatformTransaction[]
  groupOrders  GroupOrder[]
}

enum SubscriptionStatus {
  TRIAL
  ACTIVE
  PAST_DUE
  CANCELLED
  SUSPENDED
}

model TenantUser {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  email String
  role  TenantRole @default(STAFF)

  createdAt DateTime @default(now())

  @@unique([tenantId, email])
}

enum TenantRole {
  OWNER
  ADMIN
  MANAGER
  STAFF
}

// ==========================================
// LOCATIONS
// ==========================================

model Location {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  name    String
  city    String
  address String
  lat     Float
  lng     Float

  // Tax rate for this location (e.g., 0.0945 for 9.45%)
  // Includes state, local, and restaurant taxes combined
  taxRate Float @default(0.0)

  // Operating hours (JSON: { mon: { open: "11:00", close: "21:00" }, sun: null })
  operatingHours Json?
  timezone       String  @default("America/Denver")
  isClosed       Boolean @default(false) // For temporary closures

  // Wallet notification settings
  notificationRadiusMiles Float @default(0.062) // ~100 meters - Apple's actual notification trigger radius

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  seats        Seat[]
  orders       Order[]
  stats        LocationStats?
  waitQueue    WaitQueue[]
  groupOrders  GroupOrder[]
  mealGifts    MealGift[]
  kioskDevices KioskDevice[]
}

model LocationStats {
  id         String   @id @default(cuid())
  locationId String   @unique
  location   Location @relation(fields: [locationId], references: [id])

  totalSeats     Int @default(0)
  availableSeats Int @default(0)
  occupiedSeats  Int @default(0)
  avgWaitMinutes Int @default(0)

  updatedAt DateTime @updatedAt
}

// ==========================================
// KIOSK DEVICES
// ==========================================

model KioskDevice {
  id         String   @id @default(cuid())
  deviceId   String   @unique // Hardware identifier or unique device ID
  name       String // Friendly name, e.g., "Front Counter Kiosk"
  locationId String
  location   Location @relation(fields: [locationId], references: [id])

  apiKey   String  @unique // For API authentication
  isActive Boolean @default(true)

  // Monitoring
  lastHeartbeat DateTime?
  appVersion    String? // Track deployed app version
  deviceInfo    Json? // OS version, browser, etc.

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([locationId])
  @@index([isActive])
}

// ==========================================
// MENU
// ==========================================

model MenuItem {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  // Name translations (English is required, others optional)
  name     String // English (default)
  nameZhTW String? // Traditional Chinese (Taiwan)
  nameZhCN String? // Simplified Chinese (China)
  nameEs   String? // Spanish

  // Flexible pricing system
  basePriceCents       Int // Base price (can be $0 for included items)
  additionalPriceCents Int @default(0) // Price for extra servings
  includedQuantity     Int @default(0) // Number of servings included (1 for baby bok choy, 0 for others)

  category String? // e.g., "protein", "vegetables", "noodles", "main01", "slider01", etc.

  // Description translations
  description     String? // English (default)
  descriptionZhTW String? // Traditional Chinese (Taiwan)
  descriptionZhCN String? // Simplified Chinese (China)
  descriptionEs   String? // Spanish

  isAvailable Boolean @default(true)

  // Enhanced menu organization
  categoryType  CategoryType? // Type of category (MAIN, SLIDER, ADDON, etc.)
  selectionMode SelectionMode @default(MULTIPLE) // How users select this item
  displayOrder  Int           @default(0) // Sort order within category
  sliderConfig  Json? // Slider metadata: {min, max, default, labels, step}

  // Dietary information
  isVegetarian Boolean @default(false) // V - Vegetarian
  isVegan      Boolean @default(false) // VG - Vegan
  isGlutenFree Boolean @default(false) // GF - Gluten Free
  spiceLevel   Int     @default(0) // 0=none, 1=mild, 2=medium, 3=hot
  allergens    String? // Comma-separated list of allergens (e.g., "soy,sesame,egg")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orderItems OrderItem[]
}

enum CategoryType {
  MAIN
  SLIDER
  ADDON
  SIDE
  DRINK
  DESSERT
}

enum SelectionMode {
  SINGLE // Only one selection allowed (main01, main02)
  MULTIPLE // Multiple selections allowed (add-ons, sides, drinks)
  SLIDER // Slider control with levels (slider01-08)
  INCLUDED // Automatically included, can't be removed
}

// ==========================================
// SEATING
// ==========================================

model Seat {
  id         String   @id @default(cuid())
  locationId String
  location   Location @relation(fields: [locationId], references: [id])

  number String // Pod number (e.g., "01", "02", "03")
  qrCode String     @unique // QR code for pod verification
  status SeatStatus @default(AVAILABLE)

  // Position in the seating layout (for visual map)
  // U-shape: left side (entrance), bottom, right side (exit)
  row  Int    @default(0) // 0=left, 1=bottom, 2=right
  col  Int    @default(0) // Position within the row
  side String @default("left") // "left", "bottom", "right" for U-shape

  // Dual Pod configuration (two adjacent pods that can be booked together)
  podType       PodType @default(SINGLE)
  dualPartnerId String? @unique // Reference to paired seat (bidirectional)
  dualPartner   Seat?   @relation("DualPod", fields: [dualPartnerId], references: [id])
  pairedWith    Seat?   @relation("DualPod")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders   Order[]
  podCalls PodCall[]

  @@unique([locationId, number]) // Ensure unique pod numbers per location
}

enum PodType {
  SINGLE
  DUAL
}

enum SeatStatus {
  AVAILABLE
  OCCUPIED
  RESERVED
  CLEANING
}

// ==========================================
// ORDERS
// ==========================================

model Order {
  id                 String      @id @default(cuid())
  orderNumber        String      @unique // Long unique ID (e.g., "ORD-1764819716365-MI9K2P")
  kitchenOrderNumber String? // Daily sequential number (e.g., "0001", "0002")
  orderQrCode        String?     @unique // QR code for customer to scan at kiosk and pod
  status             OrderStatus @default(PENDING_PAYMENT)

  totalCents     Int
  items          OrderItem[]
  customizations Json?

  fulfillmentType  FulfillmentType @default(DINE_IN)
  estimatedArrival DateTime?

  // Lifecycle timestamps
  paidAt        DateTime? // When payment succeeded
  arrivedAt     DateTime? // When scanned at kiosk (check-in)
  queuedAt      DateTime? // When entered queue (if waiting for pod)
  prepStartTime DateTime? // When kitchen started cooking
  readyTime     DateTime? // When food finished cooking
  deliveredAt   DateTime? // When food brought to table
  completedTime DateTime? // When customer finished
  podCleanedAt  DateTime? // When pod was cleaned after customer left

  // Pod/Seat Assignment
  seatId               String?
  seat                 Seat?     @relation(fields: [seatId], references: [id])
  podAssignedAt        DateTime? // When pod was assigned
  podConfirmedAt       DateTime? // When customer scanned QR to confirm pod
  podReservationExpiry DateTime? // When reservation expires if not confirmed
  podSelectionMethod   String? // "AUTO" | "CUSTOMER_SELECTED" | "STAFF_ASSIGNED"
  podReleasedAt        DateTime? // When pod reservation was auto-released due to no-show
  podReleasedNumber    String? // Which pod was released (for notification display)

  // Dual Pod (2-person seating)
  dualPartnerSeatId String? // ID of the partner seat in a dual pod booking
  isDualPod         Boolean @default(false) // Whether this order uses a dual pod

  // Queue Management
  queuePosition        Int? // Current position in queue
  estimatedWaitMinutes Int? // Estimated wait time
  arrivalDeviation     Int? // Minutes early/late vs estimatedArrival

  // Notification tracking
  notifiedAt         DateTime? // When customer was notified of pod assignment
  notificationMethod String? // "PUSH" | "SMS" | "EMAIL"

  locationId String?
  location   Location? @relation(fields: [locationId], references: [id])
  tenantId   String
  tenant     Tenant    @relation(fields: [tenantId], references: [id])

  userId String?
  user   User?   @relation(fields: [userId], references: [id])

  // Guest checkout (alternative to userId)
  guestId   String?
  guest     Guest?  @relation(fields: [guestId], references: [id])
  guestName String? // Store guest name directly for display (especially for EVENT orders)

  // Group order association
  groupOrderId String?
  groupOrder   GroupOrder? @relation(fields: [groupOrderId], references: [id])
  isGroupHost  Boolean     @default(false)

  paymentStatus   PaymentStatus @default(PENDING)
  stripePaymentId String?

  // Payment method info (for receipts)
  paymentMethodLast4 String? // Last 4 digits of card
  paymentMethodBrand String? // visa, mastercard, amex, etc.

  // Tax tracking
  taxCents Int @default(0)

  // Order source tracking for analytics
  orderSource OrderSource @default(WEB)

  // Child orders (add-ons placed after initial order)
  parentOrderId String?
  parentOrder   Order?     @relation("OrderAddOns", fields: [parentOrderId], references: [id])
  childOrders   Order[]    @relation("OrderAddOns")
  addOnType     AddOnType? // Type of add-on for kitchen display color coding

  podCalls PodCall[]

  creditEvents   CreditEvent[]
  waitQueueEntry WaitQueue?
  mealGift       MealGift?

  // Promo code applied
  promoCodeId        String?
  promoCode          PromoCode? @relation(fields: [promoCodeId], references: [id])
  promoDiscountCents Int        @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum OrderStatus {
  PENDING_PAYMENT
  PAID
  QUEUED
  PREPPING
  READY
  SERVING // Food delivered to table, customer eating
  COMPLETED
  CANCELLED
}

enum FulfillmentType {
  DINE_IN // Default - customer orders and dines in pod
  PRE_ORDER // Order placed before arrival (legacy)
  WALK_IN // Order placed at location (legacy)
  PICKUP // Pickup order (future feature)
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

enum OrderSource {
  WEB // Order placed via web app (desktop or mobile browser)
  KIOSK // Order placed at physical kiosk in-store
  MOBILE // Order placed via native mobile app (future)
  STAFF // Order placed by staff on behalf of customer
  EVENT // Order placed for private event (e.g., CNY Party)
}

model OrderItem {
  id      String @id @default(cuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id])

  menuItemId String
  menuItem   MenuItem @relation(fields: [menuItemId], references: [id])

  quantity   Int
  priceCents Int

  // For slider items, store the display label (e.g., "Light", "Medium", "Rich")
  selectedValue String?

  createdAt DateTime @default(now())
}

// ==========================================
// GUESTS (Unauthenticated Checkout)
// ==========================================

model Guest {
  id String @id @default(cuid())

  name  String // Required at checkout
  phone String? // Optional
  email String? // Optional

  sessionToken String   @unique // For cookie-based session
  expiresAt    DateTime // Session expiry (24 hours from creation)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders            Order[]
  groupOrdersAsHost GroupOrder[] @relation("GroupOrderHost")
  groupOrders       GroupOrder[] @relation("GroupOrderMemberGuests")

  // Shop Orders
  shopOrders ShopOrder[]
}

// ==========================================
// GROUP ORDERS
// ==========================================

model GroupOrder {
  id   String @id @default(cuid())
  code String @unique // 6-character shareable code

  // Host can be either a registered user or a guest
  hostUserId  String?
  hostUser    User?   @relation("GroupOrderHost", fields: [hostUserId], references: [id])
  hostGuestId String?
  hostGuest   Guest?  @relation("GroupOrderHost", fields: [hostGuestId], references: [id])

  locationId String
  location   Location @relation(fields: [locationId], references: [id])
  tenantId   String
  tenant     Tenant   @relation(fields: [tenantId], references: [id])

  status        GroupOrderStatus    @default(GATHERING)
  paymentMethod GroupPaymentMethod?

  estimatedArrival DateTime? // When group plans to arrive
  expiresAt        DateTime // Auto-cancel time (30 min from creation)
  closedAt         DateTime? // When host closed for new members
  finalizedAt      DateTime? // When payment completed

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders       Order[]
  memberUsers  User[]  @relation("GroupOrderMemberUsers")
  memberGuests Guest[] @relation("GroupOrderMemberGuests")
}

enum GroupOrderStatus {
  GATHERING // Accepting new members
  CLOSED // No new members, awaiting payment
  PAYING // Payment in progress
  PAID // All payments complete
  PARTIALLY_PAID // Some payments complete (Pay Your Own)
  CANCELLED
}

enum GroupPaymentMethod {
  HOST_PAYS_ALL // Single charge for total
  PAY_YOUR_OWN // Each guest pays individually
}

// ==========================================
// USERS & REFERRALS
// ==========================================

model User {
  id    String  @id @default(cuid())
  email String? @unique
  phone String? @unique
  name  String?

  // Stripe integration
  stripeCustomerId String? @unique

  // Referral system
  referralCode String  @unique @default(cuid())
  referredById String?
  referredBy   User?   @relation("Referrals", fields: [referredById], references: [id])
  referrals    User[]  @relation("Referrals")

  creditsCents Int @default(0)

  // Membership tier system
  membershipTier        MembershipTier @default(CHOPSTICK)
  tierProgressOrders    Int            @default(0)
  tierProgressReferrals Int            @default(0)
  lifetimeOrderCount    Int            @default(0)
  lifetimeSpentCents    Int            @default(0)
  currentStreak         Int            @default(0)
  longestStreak         Int            @default(0)
  lastOrderDate         DateTime?

  // Arrival prediction metrics (for queue prioritization)
  avgArrivalDeviation Float? // Average minutes early/late
  arrivalAccuracy     Float? // 0-1 score of on-time arrivals
  onTimeArrivals      Int    @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders         Order[]
  creditEvents   CreditEvent[]
  pendingCredits PendingCredit[]
  badges         UserBadge[]
  challenges     UserChallenge[]

  // Group Orders
  groupOrdersAsHost GroupOrder[] @relation("GroupOrderHost")
  groupOrders       GroupOrder[] @relation("GroupOrderMemberUsers")

  // Meal for a Stranger
  givenMealGifts    MealGift[]      @relation("GivenMealGifts")
  acceptedMealGifts MealGift[]      @relation("AcceptedMealGifts")
  mealGiftChain     MealGiftChain[]

  // Wallet pass notifications
  walletRegistrations WalletPassRegistration[]
  walletNotifications WalletNotificationLog[]

  // Gift Cards
  purchasedGiftCards GiftCard[] @relation("PurchasedGiftCards")
  redeemedGiftCards  GiftCard[] @relation("RedeemedGiftCards")

  // Shop Orders
  shopOrders ShopOrder[]

  // Saved Payment Methods
  savedPaymentMethods SavedPaymentMethod[]
}

enum MembershipTier {
  CHOPSTICK
  NOODLE_MASTER
  BEEF_BOSS
}

// ==========================================
// WALLET PASS NOTIFICATIONS
// ==========================================

model WalletPassRegistration {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  deviceLibraryId String // Apple device identifier
  pushToken       String // APNs push token
  passTypeId      String // pass.com.ohbeef.loyalty
  serialNumber    String // oh-member-{userId}

  lastNotificationAt   DateTime?
  lastNotificationType String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([deviceLibraryId, passTypeId, serialNumber])
  @@index([userId])
  @@index([pushToken])
}

model WalletNotificationLog {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  notificationType String // NEAR_RESTAURANT, STREAK_AT_RISK, TIER_PROGRESS, CHALLENGE_DEADLINE, AVAILABLE_CREDITS
  locationId       String? // For location-specific notifications
  messageContent   String

  sentAt DateTime @default(now())

  @@index([userId, notificationType, sentAt])
}

model CreditEvent {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  type        CreditEventType
  amountCents Int

  orderId String?
  order   Order?  @relation(fields: [orderId], references: [id])

  description String?
  metadata    Json?

  createdAt DateTime @default(now())
}

enum CreditEventType {
  REFERRAL_SIGNUP
  REFERRAL_ORDER
  REFERRAL_ORDER_PENDING // Credit queued for next disbursement
  CASHBACK
  CREDIT_APPLIED
  CREDIT_EXPIRED
  ADMIN_ADJUSTMENT
  CHALLENGE_REWARD // Reward for completing challenges
  GIFT_EXCESS // Excess from meal gift when order < gift amount
}

// ==========================================
// PENDING CREDITS (Scheduled Disbursement)
// ==========================================

model PendingCredit {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  type        PendingCreditType
  amountCents Int

  // Reference to what triggered this credit
  sourceUserId  String? // The referred user who placed the order
  sourceOrderId String? // The order that triggered this credit

  description String?

  // Scheduling
  scheduledFor DateTime // Next disbursement date (1st or 16th)
  disbursedAt  DateTime?

  createdAt DateTime @default(now())
}

enum PendingCreditType {
  REFERRAL_ORDER // Credit from referred friend's first order
}

// ==========================================
// GAMIFICATION
// ==========================================

model Badge {
  id          String        @id @default(cuid())
  slug        String        @unique
  name        String
  description String
  iconEmoji   String
  category    BadgeCategory
  isActive    Boolean       @default(true)

  createdAt DateTime @default(now())

  userBadges UserBadge[]
}

enum BadgeCategory {
  MILESTONE
  CHALLENGE
  REFERRAL
  SPECIAL
  STREAK
}

model UserBadge {
  id      String @id @default(cuid())
  userId  String
  user    User   @relation(fields: [userId], references: [id])
  badgeId String
  badge   Badge  @relation(fields: [badgeId], references: [id])

  earnedAt DateTime @default(now())

  @@unique([userId, badgeId])
}

model Challenge {
  id          String @id @default(cuid())
  slug        String @unique
  name        String
  description String
  rewardCents Int
  iconEmoji   String

  requirements Json

  startsAt DateTime?
  endsAt   DateTime?
  isActive Boolean   @default(true)

  createdAt DateTime @default(now())

  userChallenges UserChallenge[]
}

model UserChallenge {
  id          String    @id @default(cuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  challengeId String
  challenge   Challenge @relation(fields: [challengeId], references: [id])

  progress      Json
  completedAt   DateTime?
  rewardClaimed Boolean   @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, challengeId])
}

// ==========================================
// WAIT QUEUE
// ==========================================

model WaitQueue {
  id         String   @id @default(cuid())
  orderId    String   @unique
  order      Order    @relation(fields: [orderId], references: [id])
  locationId String
  location   Location @relation(fields: [locationId], references: [id])

  arrivedAt        DateTime // Actual arrival at kiosk
  estimatedArrival DateTime? // What customer selected when ordering
  priority         Int // Calculated priority score
  status           QueueStatus @default(WAITING)

  assignedAt DateTime? // When pod assigned
  expiredAt  DateTime? // If no-show or cancelled

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([locationId, status, priority])
}

enum QueueStatus {
  WAITING // In queue, no pod yet
  ASSIGNED // Pod assigned, heading there
  CONFIRMED // At pod, confirmed
  EXPIRED // No-show or cancelled
}

// ==========================================
// POD CALLS (Customer requesting staff assistance)
// ==========================================

model PodCall {
  id         String @id @default(cuid())
  orderId    String
  order      Order  @relation(fields: [orderId], references: [id])
  seatId     String
  seat       Seat   @relation(fields: [seatId], references: [id])
  locationId String

  reason PodCallReason @default(GENERAL)
  status PodCallStatus @default(PENDING)

  // Timestamps
  createdAt      DateTime  @default(now())
  acknowledgedAt DateTime? // When staff acknowledged the call
  resolvedAt     DateTime? // When staff resolved/completed the call

  @@index([locationId, status])
  @@index([seatId])
}

enum PodCallReason {
  GENERAL // Generic "call staff" request
  REFILL // Drink refill request
  ASSISTANCE // Need help/question
  CHECK // Request check/bill
  CLEANUP // Spill or cleanup needed
}

enum PodCallStatus {
  PENDING // Not yet seen by staff
  ACKNOWLEDGED // Staff has seen it, on their way
  RESOLVED // Completed
  CANCELLED // Customer cancelled the request
}

// ==========================================
// ADD-ON ORDER TYPES (for kitchen display color coding)
// ==========================================

// Note: Add-on orders use the existing Order model with:
// - parentOrderId pointing to the original order
// - addOnType to indicate the type of add-on (for kitchen display color coding)
// Add this enum for use in a new field on Order

enum AddOnType {
  PAID_ADDON // Amber - paid add-ons (extra meat, sides)
  REFILL // Blue - free drink refill
  EXTRA_VEG // Green - free extra vegetables
  DESSERT_READY // Pink - customer is ready for dessert
}

// ==========================================
// PLATFORM REVENUE
// ==========================================

model PlatformTransaction {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  type             TransactionType
  amountCents      Int
  platformFeeCents Int
  tenantNetCents   Int

  metadata Json?

  createdAt DateTime @default(now())
}

enum TransactionType {
  ORDER
  SUBSCRIPTION
  REFUND
}

// ==========================================
// LANGUAGE ANALYTICS
// ==========================================

model LanguageVisit {
  id String @id @default(cuid())

  browserLanguage String // Raw Accept-Language header value (e.g., "zh-TW,zh;q=0.9,en;q=0.8")
  primaryLanguage String // Primary language code (e.g., "zh-TW", "fr", "de")
  resolvedLocale  String // The locale actually shown (e.g., "en", "zh-TW")
  wasSupported    Boolean // Whether primaryLanguage was supported

  // Optional user/session tracking
  userId    String?
  sessionId String? // Anonymous session ID

  // Request context
  userAgent String?
  country   String? // From IP geolocation if available

  createdAt DateTime @default(now())

  @@index([primaryLanguage])
  @@index([resolvedLocale])
  @@index([createdAt])
}

// ==========================================
// MEAL FOR A STRANGER CHALLENGE
// ==========================================

model MealGift {
  id         String   @id @default(cuid())
  giverId    String
  giver      User     @relation("GivenMealGifts", fields: [giverId], references: [id])
  locationId String
  location   Location @relation(fields: [locationId], references: [id])

  amountCents      Int // Gift amount (5.99 - 5.00)
  messageFromGiver String? // Optional message from giver
  payForwardCount  Int     @default(0) // How many times it was paid forward

  status MealGiftStatus @default(PENDING)

  // Tracking
  acceptedById String? // Final recipient who accepted
  acceptedBy   User?   @relation("AcceptedMealGifts", fields: [acceptedById], references: [id])
  orderId      String? @unique // Order where gift was applied
  order        Order?  @relation(fields: [orderId], references: [id])

  // Timestamps
  createdAt  DateTime  @default(now())
  expiresAt  DateTime // End of business day at location
  acceptedAt DateTime? // When finally accepted
  expiredAt  DateTime? // When it expired and was refunded

  // Chain tracking
  chain MealGiftChain[]

  @@index([locationId, status, createdAt])
  @@index([giverId])
}

model MealGiftChain {
  id          String   @id @default(cuid())
  mealGiftId  String
  mealGift    MealGift @relation(fields: [mealGiftId], references: [id])
  recipientId String
  recipient   User     @relation(fields: [recipientId], references: [id])

  action               MealGiftAction // ACCEPTED or PAID_FORWARD
  messageFromRecipient String? // Optional thank you or message

  createdAt DateTime @default(now())

  @@index([mealGiftId])
}

enum MealGiftStatus {
  PENDING // Waiting for someone to claim
  ACCEPTED // Someone accepted and used it
  EXPIRED // End of day, refunded to giver as credit
}

enum MealGiftAction {
  ACCEPTED // Recipient applied to their order
  PAID_FORWARD // Recipient passed to next person
}

// ==========================================
// GIFT CARDS
// ==========================================

model GiftCard {
  id   String @id @default(cuid())
  code String @unique // XXXX-XXXX-XXXX-XXXX format

  amountCents  Int // Original gift card value
  balanceCents Int // Remaining balance (for partial use)
  designId     String @default("classic") // "classic", "dark", "gold"

  // Purchaser (optional - guest purchases allowed)
  purchaserId String?
  purchaser   User?   @relation("PurchasedGiftCards", fields: [purchaserId], references: [id])

  // Recipient info for email delivery
  recipientEmail  String?
  recipientName   String?
  personalMessage String?

  // Payment tracking
  stripePaymentId String?

  // Promo code applied during purchase
  promoCodeId        String?
  promoCode          PromoCode? @relation(fields: [promoCodeId], references: [id])
  promoDiscountCents Int        @default(0)

  status GiftCardStatus @default(ACTIVE)

  // Admin
  adminNotes String? // Internal notes for staff

  // Timestamps
  purchasedAt  DateTime  @default(now())
  deliveredAt  DateTime? // When email was sent
  redeemedById String? // User who added to balance
  redeemedBy   User?     @relation("RedeemedGiftCards", fields: [redeemedById], references: [id])
  redeemedAt   DateTime?
  expiresAt    DateTime? // Optional expiration

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Orders where this gift card was applied
  shopOrders ShopOrder[]

  @@index([code])
  @@index([purchaserId])
  @@index([status])
}

enum GiftCardStatus {
  ACTIVE // Can be redeemed or used at checkout
  REDEEMED // Added to user balance (full balance consumed)
  EXHAUSTED // Used at checkout, balance is zero
  EXPIRED
  CANCELLED
}

// ==========================================
// SHOP PRODUCTS (E-commerce)
// ==========================================

model ShopProduct {
  id   String  @id @default(cuid())
  slug String  @unique
  sku  String? @unique // Stock keeping unit

  // Name translations
  name     String
  nameZhTW String?
  nameZhCN String?
  nameEs   String?

  // Description translations
  description     String?
  descriptionZhTW String?
  descriptionZhCN String?
  descriptionEs   String?

  priceCents Int
  category   ShopCategory
  imageUrl   String?

  // Availability and inventory
  isAvailable       Boolean @default(true)
  stockCount        Int? // null = unlimited, 0 = out of stock
  lowStockThreshold Int? // Alert when stock drops below this

  // For variants (sizes, colors, etc.)
  // Example: [{size: "S", stock: 5, sku: "TSH-S"}, {size: "M", stock: 10, sku: "TSH-M"}]
  variants Json?

  // QR code for in-store scanning
  qrCode String? @unique // Unique identifier for QR code

  // Location-specific inventory (optional)
  // If empty array, product available everywhere
  // Otherwise, only at specified locations
  locationIds String[]

  // Weight for shipping calculations (in ounces)
  weightOz Float?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orderItems ShopOrderItem[]

  @@index([category])
  @@index([isAvailable])
}

enum ShopCategory {
  FOOD // Home Kit, Beef Broth Concentrate
  CONDIMENTS // Chili Oil, etc.
  MERCHANDISE // Ceramic Bowl, Chopsticks, Apron
  APPAREL // T-Shirt, Hoodie
  LIMITED_EDITION // Special items like Wooden Bowl
}

// ==========================================
// SHOP ORDERS
// ==========================================

model ShopOrder {
  id          String @id @default(cuid())
  orderNumber String @unique

  // Customer (user or guest)
  userId  String?
  user    User?   @relation(fields: [userId], references: [id])
  guestId String?
  guest   Guest?  @relation(fields: [guestId], references: [id])

  // Location for in-store pickup orders
  locationId String?

  items ShopOrderItem[]

  // Pricing
  subtotalCents Int
  shippingCents Int @default(0)
  taxCents      Int @default(0)
  totalCents    Int

  // Credits and gift cards applied (NO LIMIT for shop orders)
  creditsApplied  Int       @default(0)
  giftCardApplied Int       @default(0)
  giftCardId      String?
  giftCard        GiftCard? @relation(fields: [giftCardId], references: [id])

  // Promo code applied
  promoCodeId        String?
  promoCode          PromoCode? @relation(fields: [promoCodeId], references: [id])
  promoDiscountCents Int        @default(0)

  // Fulfillment type
  fulfillmentType ShopFulfillmentType

  // Shipping address (for SHIPPING type)
  shippingName     String?
  shippingAddress1 String?
  shippingAddress2 String?
  shippingCity     String?
  shippingState    String?
  shippingZip      String?
  shippingCountry  String? @default("US")
  shippingPhone    String?
  shippingEmail    String?

  // Payment
  stripePaymentId String?
  paymentStatus   PaymentStatus @default(PENDING)

  // Fulfillment tracking
  fulfillmentStatus ShopFulfillmentStatus @default(PENDING)
  trackingNumber    String?
  trackingUrl       String?
  trackingCarrier   String? // e.g., "USPS", "UPS", "FedEx" - for future ShipStation integration
  shippedAt         DateTime?
  deliveredAt       DateTime?
  pickedUpAt        DateTime? // For in-store pickup

  // Admin
  adminNotes String? // Internal notes for staff

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([paymentStatus])
  @@index([fulfillmentStatus])
  @@index([orderNumber])
}

enum ShopFulfillmentType {
  SHIPPING // Ship to customer address
  IN_STORE_PICKUP // Customer picks up at location
}

enum ShopFulfillmentStatus {
  PENDING // Awaiting processing
  PROCESSING // Being prepared
  SHIPPED // Shipped (for shipping orders)
  READY_PICKUP // Ready for pickup (for in-store)
  COMPLETED // Delivered or picked up
  CANCELLED
}

model ShopOrderItem {
  id        String      @id @default(cuid())
  orderId   String
  order     ShopOrder   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId String
  product   ShopProduct @relation(fields: [productId], references: [id])

  quantity   Int
  priceCents Int // Price at time of purchase

  // For variant items (size, color, etc.)
  variant String?

  createdAt DateTime @default(now())

  @@index([orderId])
  @@index([productId])
}

// ==========================================
// PROMO CODES
// ==========================================

model PromoCode {
  id   String @id @default(cuid())
  code String @unique // e.g., "SUMMER20", "FREESHIP50"

  // Discount Configuration
  discountType     PromoDiscountType
  discountValue    Int // Cents for FIXED_AMOUNT, percentage (0-100) for PERCENTAGE
  maxDiscountCents Int? // Cap for percentage discounts (e.g., max $50 off)

  // Scope - where this code can be used
  scope PromoScope @default(ALL)

  // Category/Product targeting (arrays for flexibility)
  // For MENU scope: ["MAIN", "SLIDER", "ADDON", "SIDE", "DRINK", "DESSERT"]
  // For SHOP scope: ["FOOD", "CONDIMENTS", "MERCHANDISE", "APPAREL", "LIMITED_EDITION"]
  targetCategories   String[] // Empty = all categories
  targetProductIds   String[] // Empty = all products, specific IDs = only those products
  excludedProductIds String[] // Products explicitly excluded

  // Location restrictions
  locationIds String[] // Empty = all locations

  // Usage Limits
  totalUsageLimit   Int? // null = unlimited
  perUserLimit      Int  @default(1)
  currentUsageCount Int  @default(0)

  // Order Requirements
  minimumOrderCents Int? // Minimum subtotal required

  // Validity Period
  startsAt  DateTime @default(now())
  expiresAt DateTime?

  // Status
  isActive Boolean @default(true)

  // Metadata
  description String? // Internal description for admin
  createdById String? // Admin who created it

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  usages     PromoCodeUsage[]
  orders     Order[]
  shopOrders ShopOrder[]
  giftCards  GiftCard[]

  @@index([code])
  @@index([isActive, expiresAt])
  @@index([scope])
}

enum PromoDiscountType {
  PERCENTAGE // e.g., 20% off
  FIXED_AMOUNT // e.g., $10 off
  FREE_SHIPPING // Waive shipping cost (shop orders only)
}

enum PromoScope {
  ALL // Works on menu orders, shop orders, and gift cards
  MENU // Menu/dining orders only
  SHOP // E-commerce shop orders only
  GIFT_CARD // Gift card purchases only
}

model PromoCodeUsage {
  id          String    @id @default(cuid())
  promoCodeId String
  promoCode   PromoCode @relation(fields: [promoCodeId], references: [id])

  // Who used it
  userId  String?
  guestId String?

  // What it was applied to (only one will be set)
  orderId     String? // For menu orders
  shopOrderId String? // For shop orders
  giftCardId  String? // For gift card purchases

  // Discount applied
  discountCents Int

  createdAt DateTime @default(now())

  @@index([promoCodeId])
  @@index([userId])
}

// ==========================================
// GIFT CARD CONFIGURATION
// ==========================================

model GiftCardConfig {
  id String @id @default(cuid())

  // Configuration type
  configType GiftCardConfigType

  // For DENOMINATION type (preset amounts)
  amountCents Int?
  isPreset    Boolean @default(true) // false = custom amount range config

  // For custom amount range (only one record with isPreset=false)
  minAmountCents Int?
  maxAmountCents Int?

  // For DESIGN type
  designId   String? @unique // e.g., "classic", "dark", "gold"
  designName String?
  gradient   String? // CSS gradient string

  // Ordering and display
  displayOrder Int     @default(0)
  isActive     Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([configType, isActive])
}

enum GiftCardConfigType {
  DENOMINATION
  DESIGN
}

// ==========================================
// PARTY INVITATIONS
// ==========================================

model PartyInvitation {
  id   String @id @default(cuid())
  code String @unique // URL-friendly code (e.g., "cny2026")

  // Event Details
  title       String // "Chinese New Year Celebration 2026"
  hostName    String // "The Didericksen Family"
  eventDate   DateTime
  eventTime   String // "6:00 PM"
  location    String // Full address
  dresscode   String? // "Festive Red & Gold"
  description String? // Additional details

  // Chinese New Year specific
  zodiacYear   String? // "蛇年"
  zodiacEnglish String? // "Year of the Snake"

  // Settings
  maxGuests        Int? // Maximum total guests allowed (null = unlimited)
  rsvpDeadline     DateTime? // RSVP cutoff date
  allowPlusOnes    Boolean @default(true)
  maxGuestsPerRsvp Int     @default(4) // Max guests per RSVP submission

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  rsvps PartyRSVP[]
}

model PartyRSVP {
  id          String          @id @default(cuid())
  invitationId String
  invitation   PartyInvitation @relation(fields: [invitationId], references: [id])

  // Guest info
  name       String
  phone      String?
  email      String?
  guestCount Int     @default(1) // Number of guests attending (including self)

  // RSVP status
  status PartyRSVPStatus @default(ATTENDING)

  // Optional message from guest
  message String?

  // Metadata
  ipAddress String? // For spam prevention
  userAgent String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([invitationId])
  @@index([status])
}

enum PartyRSVPStatus {
  ATTENDING     // Will be there
  NOT_ATTENDING // Can't make it
  MAYBE         // Tentative
}

// ==========================================
// SAVED PAYMENT METHODS
// ==========================================

model SavedPaymentMethod {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  stripePaymentMethodId String  @unique
  type                  String // "card", "link", etc.
  last4                 String?
  brand                 String? // "visa", "mastercard", "amex", etc.
  expiryMonth           Int?
  expiryYear            Int?

  isDefault Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}
