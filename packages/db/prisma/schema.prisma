// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==========================================
// TENANT & MULTI-TENANCY
// ==========================================

model Tenant {
  id           String  @id @default(cuid())
  slug         String  @unique
  brandName    String
  logoUrl      String?
  primaryColor String  @default("#667eea")
  domain       String?

  stripeAccountId    String?
  subscriptionStatus SubscriptionStatus @default(TRIAL)
  subscriptionTier   String             @default("starter")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  locations    Location[]
  menuItems    MenuItem[]
  orders       Order[]
  users        TenantUser[]
  transactions PlatformTransaction[]
  groupOrders  GroupOrder[]
}

enum SubscriptionStatus {
  TRIAL
  ACTIVE
  PAST_DUE
  CANCELLED
  SUSPENDED
}

model TenantUser {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  email String
  role  TenantRole @default(STAFF)

  createdAt DateTime @default(now())

  @@unique([tenantId, email])
}

enum TenantRole {
  OWNER
  ADMIN
  MANAGER
  STAFF
}

// ==========================================
// LOCATIONS
// ==========================================

model Location {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  name    String
  city    String
  address String
  lat     Float
  lng     Float

  // Tax rate for this location (e.g., 0.0945 for 9.45%)
  // Includes state, local, and restaurant taxes combined
  taxRate Float @default(0.0)

  // Operating hours (JSON: { mon: { open: "11:00", close: "21:00" }, sun: null })
  operatingHours Json?
  timezone       String  @default("America/Denver")
  isClosed       Boolean @default(false) // For temporary closures

  // Wallet notification settings
  notificationRadiusMiles Float @default(0.062) // ~100 meters - Apple's actual notification trigger radius

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  seats       Seat[]
  orders      Order[]
  stats       LocationStats?
  waitQueue   WaitQueue[]
  groupOrders GroupOrder[]
  mealGifts   MealGift[]
}

model LocationStats {
  id         String   @id @default(cuid())
  locationId String   @unique
  location   Location @relation(fields: [locationId], references: [id])

  totalSeats     Int @default(0)
  availableSeats Int @default(0)
  occupiedSeats  Int @default(0)
  avgWaitMinutes Int @default(0)

  updatedAt DateTime @updatedAt
}

// ==========================================
// MENU
// ==========================================

model MenuItem {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  // Name translations (English is required, others optional)
  name     String  // English (default)
  nameZhTW String? // Traditional Chinese (Taiwan)
  nameZhCN String? // Simplified Chinese (China)
  nameEs   String? // Spanish

  // Flexible pricing system
  basePriceCents       Int // Base price (can be $0 for included items)
  additionalPriceCents Int @default(0) // Price for extra servings
  includedQuantity     Int @default(0) // Number of servings included (1 for baby bok choy, 0 for others)

  category    String? // e.g., "protein", "vegetables", "noodles", "main01", "slider01", etc.

  // Description translations
  description     String? // English (default)
  descriptionZhTW String? // Traditional Chinese (Taiwan)
  descriptionZhCN String? // Simplified Chinese (China)
  descriptionEs   String? // Spanish

  isAvailable Boolean @default(true)

  // Enhanced menu organization
  categoryType  CategoryType? // Type of category (MAIN, SLIDER, ADDON, etc.)
  selectionMode SelectionMode @default(MULTIPLE) // How users select this item
  displayOrder  Int           @default(0) // Sort order within category
  sliderConfig  Json? // Slider metadata: {min, max, default, labels, step}

  // Dietary information
  isVegetarian  Boolean @default(false) // V - Vegetarian
  isVegan       Boolean @default(false) // VG - Vegan
  isGlutenFree  Boolean @default(false) // GF - Gluten Free
  spiceLevel    Int     @default(0) // 0=none, 1=mild, 2=medium, 3=hot
  allergens     String? // Comma-separated list of allergens (e.g., "soy,sesame,egg")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orderItems OrderItem[]
}

enum CategoryType {
  MAIN
  SLIDER
  ADDON
  SIDE
  DRINK
  DESSERT
}

enum SelectionMode {
  SINGLE // Only one selection allowed (main01, main02)
  MULTIPLE // Multiple selections allowed (add-ons, sides, drinks)
  SLIDER // Slider control with levels (slider01-08)
  INCLUDED // Automatically included, can't be removed
}

// ==========================================
// SEATING
// ==========================================

model Seat {
  id         String   @id @default(cuid())
  locationId String
  location   Location @relation(fields: [locationId], references: [id])

  number String // Pod number (e.g., "01", "02", "03")
  qrCode String     @unique // QR code for pod verification
  status SeatStatus @default(AVAILABLE)

  // Position in the seating layout (for visual map)
  // U-shape: left side (entrance), bottom, right side (exit)
  row  Int    @default(0) // 0=left, 1=bottom, 2=right
  col  Int    @default(0) // Position within the row
  side String @default("left") // "left", "bottom", "right" for U-shape

  // Dual Pod configuration (two adjacent pods that can be booked together)
  podType       PodType @default(SINGLE)
  dualPartnerId String? @unique // Reference to paired seat (bidirectional)
  dualPartner   Seat?   @relation("DualPod", fields: [dualPartnerId], references: [id])
  pairedWith    Seat?   @relation("DualPod")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders   Order[]
  podCalls PodCall[]

  @@unique([locationId, number]) // Ensure unique pod numbers per location
}

enum PodType {
  SINGLE
  DUAL
}

enum SeatStatus {
  AVAILABLE
  OCCUPIED
  RESERVED
  CLEANING
}

// ==========================================
// ORDERS
// ==========================================

model Order {
  id                 String      @id @default(cuid())
  orderNumber        String      @unique // Long unique ID (e.g., "ORD-1764819716365-MI9K2P")
  kitchenOrderNumber String? // Daily sequential number (e.g., "0001", "0002")
  orderQrCode        String?     @unique // QR code for customer to scan at kiosk and pod
  status             OrderStatus @default(PENDING_PAYMENT)

  totalCents     Int
  items          OrderItem[]
  customizations Json?

  fulfillmentType  FulfillmentType @default(DINE_IN)
  estimatedArrival DateTime?

  // Lifecycle timestamps
  paidAt        DateTime? // When payment succeeded
  arrivedAt     DateTime? // When scanned at kiosk (check-in)
  queuedAt      DateTime? // When entered queue (if waiting for pod)
  prepStartTime DateTime? // When kitchen started cooking
  readyTime     DateTime? // When food finished cooking
  deliveredAt   DateTime? // When food brought to table
  completedTime DateTime? // When customer finished
  podCleanedAt  DateTime? // When pod was cleaned after customer left

  // Pod/Seat Assignment
  seatId               String?
  seat                 Seat?     @relation(fields: [seatId], references: [id])
  podAssignedAt        DateTime? // When pod was assigned
  podConfirmedAt       DateTime? // When customer scanned QR to confirm pod
  podReservationExpiry DateTime? // When reservation expires if not confirmed
  podSelectionMethod   String? // "AUTO" | "CUSTOMER_SELECTED" | "STAFF_ASSIGNED"
  podReleasedAt        DateTime? // When pod reservation was auto-released due to no-show
  podReleasedNumber    String? // Which pod was released (for notification display)

  // Dual Pod (2-person seating)
  dualPartnerSeatId  String? // ID of the partner seat in a dual pod booking
  isDualPod          Boolean @default(false) // Whether this order uses a dual pod

  // Queue Management
  queuePosition        Int? // Current position in queue
  estimatedWaitMinutes Int? // Estimated wait time
  arrivalDeviation     Int? // Minutes early/late vs estimatedArrival

  // Notification tracking
  notifiedAt         DateTime? // When customer was notified of pod assignment
  notificationMethod String? // "PUSH" | "SMS" | "EMAIL"

  locationId String?
  location   Location? @relation(fields: [locationId], references: [id])
  tenantId   String
  tenant     Tenant    @relation(fields: [tenantId], references: [id])

  userId String?
  user   User?   @relation(fields: [userId], references: [id])

  // Guest checkout (alternative to userId)
  guestId String?
  guest   Guest?  @relation(fields: [guestId], references: [id])

  // Group order association
  groupOrderId String?
  groupOrder   GroupOrder? @relation(fields: [groupOrderId], references: [id])
  isGroupHost  Boolean     @default(false)

  paymentStatus   PaymentStatus @default(PENDING)
  stripePaymentId String?

  // Order source tracking for analytics
  orderSource OrderSource @default(WEB)

  // Child orders (add-ons placed after initial order)
  parentOrderId String?
  parentOrder   Order?     @relation("OrderAddOns", fields: [parentOrderId], references: [id])
  childOrders   Order[]    @relation("OrderAddOns")
  addOnType     AddOnType? // Type of add-on for kitchen display color coding

  podCalls PodCall[]

  creditEvents   CreditEvent[]
  waitQueueEntry WaitQueue?
  mealGift      MealGift?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum OrderStatus {
  PENDING_PAYMENT
  PAID
  QUEUED
  PREPPING
  READY
  SERVING // Food delivered to table, customer eating
  COMPLETED
  CANCELLED
}

enum FulfillmentType {
  DINE_IN // Default - customer orders and dines in pod
  PRE_ORDER // Order placed before arrival (legacy)
  WALK_IN // Order placed at location (legacy)
  PICKUP // Pickup order (future feature)
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

enum OrderSource {
  WEB       // Order placed via web app (desktop or mobile browser)
  KIOSK     // Order placed at physical kiosk in-store
  MOBILE    // Order placed via native mobile app (future)
  STAFF     // Order placed by staff on behalf of customer
}

model OrderItem {
  id      String @id @default(cuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id])

  menuItemId String
  menuItem   MenuItem @relation(fields: [menuItemId], references: [id])

  quantity   Int
  priceCents Int

  // For slider items, store the display label (e.g., "Light", "Medium", "Rich")
  selectedValue String?

  createdAt DateTime @default(now())
}

// ==========================================
// GUESTS (Unauthenticated Checkout)
// ==========================================

model Guest {
  id String @id @default(cuid())

  name  String // Required at checkout
  phone String? // Optional
  email String? // Optional

  sessionToken String   @unique // For cookie-based session
  expiresAt    DateTime // Session expiry (24 hours from creation)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders            Order[]
  groupOrdersAsHost GroupOrder[] @relation("GroupOrderHost")
  groupOrders       GroupOrder[] @relation("GroupOrderMemberGuests")
}

// ==========================================
// GROUP ORDERS
// ==========================================

model GroupOrder {
  id   String @id @default(cuid())
  code String @unique // 6-character shareable code

  // Host can be either a registered user or a guest
  hostUserId  String?
  hostUser    User?   @relation("GroupOrderHost", fields: [hostUserId], references: [id])
  hostGuestId String?
  hostGuest   Guest?  @relation("GroupOrderHost", fields: [hostGuestId], references: [id])

  locationId String
  location   Location @relation(fields: [locationId], references: [id])
  tenantId   String
  tenant     Tenant   @relation(fields: [tenantId], references: [id])

  status        GroupOrderStatus    @default(GATHERING)
  paymentMethod GroupPaymentMethod?

  estimatedArrival DateTime? // When group plans to arrive
  expiresAt        DateTime // Auto-cancel time (30 min from creation)
  closedAt         DateTime? // When host closed for new members
  finalizedAt      DateTime? // When payment completed

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders       Order[]
  memberUsers  User[]  @relation("GroupOrderMemberUsers")
  memberGuests Guest[] @relation("GroupOrderMemberGuests")
}

enum GroupOrderStatus {
  GATHERING // Accepting new members
  CLOSED // No new members, awaiting payment
  PAYING // Payment in progress
  PAID // All payments complete
  PARTIALLY_PAID // Some payments complete (Pay Your Own)
  CANCELLED
}

enum GroupPaymentMethod {
  HOST_PAYS_ALL // Single charge for total
  PAY_YOUR_OWN // Each guest pays individually
}

// ==========================================
// USERS & REFERRALS
// ==========================================

model User {
  id    String  @id @default(cuid())
  email String? @unique
  phone String? @unique
  name  String?

  // Referral system
  referralCode String  @unique @default(cuid())
  referredById String?
  referredBy   User?   @relation("Referrals", fields: [referredById], references: [id])
  referrals    User[]  @relation("Referrals")

  creditsCents Int @default(0)

  // Membership tier system
  membershipTier        MembershipTier @default(CHOPSTICK)
  tierProgressOrders    Int            @default(0)
  tierProgressReferrals Int            @default(0)
  lifetimeOrderCount    Int            @default(0)
  lifetimeSpentCents    Int            @default(0)
  currentStreak         Int            @default(0)
  longestStreak         Int            @default(0)
  lastOrderDate         DateTime?

  // Arrival prediction metrics (for queue prioritization)
  avgArrivalDeviation Float? // Average minutes early/late
  arrivalAccuracy     Float? // 0-1 score of on-time arrivals
  onTimeArrivals      Int    @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders         Order[]
  creditEvents   CreditEvent[]
  pendingCredits PendingCredit[]
  badges         UserBadge[]
  challenges     UserChallenge[]

  // Group Orders
  groupOrdersAsHost GroupOrder[] @relation("GroupOrderHost")
  groupOrders       GroupOrder[] @relation("GroupOrderMemberUsers")
  
  // Meal for a Stranger
  givenMealGifts    MealGift[]      @relation("GivenMealGifts")
  acceptedMealGifts MealGift[]      @relation("AcceptedMealGifts")
  mealGiftChain     MealGiftChain[]

  // Wallet pass notifications
  walletRegistrations WalletPassRegistration[]
  walletNotifications WalletNotificationLog[]
}

enum MembershipTier {
  CHOPSTICK
  NOODLE_MASTER
  BEEF_BOSS
}

// ==========================================
// WALLET PASS NOTIFICATIONS
// ==========================================

model WalletPassRegistration {
  id                   String   @id @default(cuid())
  userId               String
  user                 User     @relation(fields: [userId], references: [id])

  deviceLibraryId      String   // Apple device identifier
  pushToken            String   // APNs push token
  passTypeId           String   // pass.com.ohbeef.loyalty
  serialNumber         String   // oh-member-{userId}

  lastNotificationAt   DateTime?
  lastNotificationType String?

  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  @@unique([deviceLibraryId, passTypeId, serialNumber])
  @@index([userId])
  @@index([pushToken])
}

model WalletNotificationLog {
  id               String   @id @default(cuid())
  userId           String
  user             User     @relation(fields: [userId], references: [id])

  notificationType String   // NEAR_RESTAURANT, STREAK_AT_RISK, TIER_PROGRESS, CHALLENGE_DEADLINE, AVAILABLE_CREDITS
  locationId       String?  // For location-specific notifications
  messageContent   String

  sentAt           DateTime @default(now())

  @@index([userId, notificationType, sentAt])
}

model CreditEvent {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  type        CreditEventType
  amountCents Int

  orderId String?
  order   Order?  @relation(fields: [orderId], references: [id])

  description String?
  metadata    Json?

  createdAt DateTime @default(now())
}

enum CreditEventType {
  REFERRAL_SIGNUP
  REFERRAL_ORDER
  REFERRAL_ORDER_PENDING // Credit queued for next disbursement
  CASHBACK
  CREDIT_APPLIED
  CREDIT_EXPIRED
  ADMIN_ADJUSTMENT
  CHALLENGE_REWARD // Reward for completing challenges
  GIFT_EXCESS // Excess from meal gift when order < gift amount
}

// ==========================================
// PENDING CREDITS (Scheduled Disbursement)
// ==========================================

model PendingCredit {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  type        PendingCreditType
  amountCents Int

  // Reference to what triggered this credit
  sourceUserId  String? // The referred user who placed the order
  sourceOrderId String? // The order that triggered this credit

  description String?

  // Scheduling
  scheduledFor DateTime // Next disbursement date (1st or 16th)
  disbursedAt  DateTime?

  createdAt DateTime @default(now())
}

enum PendingCreditType {
  REFERRAL_ORDER // Credit from referred friend's first order
}

// ==========================================
// GAMIFICATION
// ==========================================

model Badge {
  id          String        @id @default(cuid())
  slug        String        @unique
  name        String
  description String
  iconEmoji   String
  category    BadgeCategory
  isActive    Boolean       @default(true)

  createdAt DateTime @default(now())

  userBadges UserBadge[]
}

enum BadgeCategory {
  MILESTONE
  CHALLENGE
  REFERRAL
  SPECIAL
  STREAK
}

model UserBadge {
  id      String @id @default(cuid())
  userId  String
  user    User   @relation(fields: [userId], references: [id])
  badgeId String
  badge   Badge  @relation(fields: [badgeId], references: [id])

  earnedAt DateTime @default(now())

  @@unique([userId, badgeId])
}

model Challenge {
  id          String @id @default(cuid())
  slug        String @unique
  name        String
  description String
  rewardCents Int
  iconEmoji   String

  requirements Json

  startsAt DateTime?
  endsAt   DateTime?
  isActive Boolean   @default(true)

  createdAt DateTime @default(now())

  userChallenges UserChallenge[]
}

model UserChallenge {
  id          String    @id @default(cuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  challengeId String
  challenge   Challenge @relation(fields: [challengeId], references: [id])

  progress      Json
  completedAt   DateTime?
  rewardClaimed Boolean   @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, challengeId])
}

// ==========================================
// WAIT QUEUE
// ==========================================

model WaitQueue {
  id         String   @id @default(cuid())
  orderId    String   @unique
  order      Order    @relation(fields: [orderId], references: [id])
  locationId String
  location   Location @relation(fields: [locationId], references: [id])

  arrivedAt        DateTime // Actual arrival at kiosk
  estimatedArrival DateTime? // What customer selected when ordering
  priority         Int // Calculated priority score
  status           QueueStatus @default(WAITING)

  assignedAt DateTime? // When pod assigned
  expiredAt  DateTime? // If no-show or cancelled

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([locationId, status, priority])
}

enum QueueStatus {
  WAITING // In queue, no pod yet
  ASSIGNED // Pod assigned, heading there
  CONFIRMED // At pod, confirmed
  EXPIRED // No-show or cancelled
}

// ==========================================
// POD CALLS (Customer requesting staff assistance)
// ==========================================

model PodCall {
  id         String @id @default(cuid())
  orderId    String
  order      Order  @relation(fields: [orderId], references: [id])
  seatId     String
  seat       Seat   @relation(fields: [seatId], references: [id])
  locationId String

  reason PodCallReason @default(GENERAL)
  status PodCallStatus @default(PENDING)

  // Timestamps
  createdAt      DateTime  @default(now())
  acknowledgedAt DateTime? // When staff acknowledged the call
  resolvedAt     DateTime? // When staff resolved/completed the call

  @@index([locationId, status])
  @@index([seatId])
}

enum PodCallReason {
  GENERAL // Generic "call staff" request
  REFILL // Drink refill request
  ASSISTANCE // Need help/question
  CHECK // Request check/bill
  CLEANUP // Spill or cleanup needed
}

enum PodCallStatus {
  PENDING // Not yet seen by staff
  ACKNOWLEDGED // Staff has seen it, on their way
  RESOLVED // Completed
  CANCELLED // Customer cancelled the request
}

// ==========================================
// ADD-ON ORDER TYPES (for kitchen display color coding)
// ==========================================

// Note: Add-on orders use the existing Order model with:
// - parentOrderId pointing to the original order
// - addOnType to indicate the type of add-on (for kitchen display color coding)
// Add this enum for use in a new field on Order

enum AddOnType {
  PAID_ADDON // Amber - paid add-ons (extra meat, sides)
  REFILL // Blue - free drink refill
  EXTRA_VEG // Green - free extra vegetables
  DESSERT_READY // Pink - customer is ready for dessert
}

// ==========================================
// PLATFORM REVENUE
// ==========================================

model PlatformTransaction {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  type             TransactionType
  amountCents      Int
  platformFeeCents Int
  tenantNetCents   Int

  metadata Json?

  createdAt DateTime @default(now())
}

enum TransactionType {
  ORDER
  SUBSCRIPTION
  REFUND
}

// ==========================================
// LANGUAGE ANALYTICS
// ==========================================

model LanguageVisit {
  id String @id @default(cuid())

  browserLanguage  String // Raw Accept-Language header value (e.g., "zh-TW,zh;q=0.9,en;q=0.8")
  primaryLanguage  String // Primary language code (e.g., "zh-TW", "fr", "de")
  resolvedLocale   String // The locale actually shown (e.g., "en", "zh-TW")
  wasSupported     Boolean // Whether primaryLanguage was supported

  // Optional user/session tracking
  userId    String?
  sessionId String? // Anonymous session ID

  // Request context
  userAgent String?
  country   String? // From IP geolocation if available

  createdAt DateTime @default(now())

  @@index([primaryLanguage])
  @@index([resolvedLocale])
  @@index([createdAt])
}

// ==========================================
// MEAL FOR A STRANGER CHALLENGE
// ==========================================

model MealGift {
  id         String   @id @default(cuid())
  giverId    String
  giver      User     @relation("GivenMealGifts", fields: [giverId], references: [id])
  locationId String
  location   Location @relation(fields: [locationId], references: [id])

  amountCents       Int // Gift amount (5.99 - 5.00)
  messageFromGiver  String? // Optional message from giver
  payForwardCount   Int @default(0) // How many times it was paid forward

  status MealGiftStatus @default(PENDING)
  
  // Tracking
  acceptedById String? // Final recipient who accepted
  acceptedBy   User?   @relation("AcceptedMealGifts", fields: [acceptedById], references: [id])
  orderId      String? @unique // Order where gift was applied
  order        Order?  @relation(fields: [orderId], references: [id])

  // Timestamps
  createdAt DateTime  @default(now())
  expiresAt DateTime  // End of business day at location
  acceptedAt DateTime? // When finally accepted
  expiredAt  DateTime? // When it expired and was refunded

  // Chain tracking
  chain MealGiftChain[]

  @@index([locationId, status, createdAt])
  @@index([giverId])
}

model MealGiftChain {
  id          String   @id @default(cuid())
  mealGiftId  String
  mealGift    MealGift @relation(fields: [mealGiftId], references: [id])
  recipientId String
  recipient   User     @relation(fields: [recipientId], references: [id])

  action              MealGiftAction // ACCEPTED or PAID_FORWARD
  messageFromRecipient String? // Optional thank you or message

  createdAt DateTime @default(now())

  @@index([mealGiftId])
}

enum MealGiftStatus {
  PENDING  // Waiting for someone to claim
  ACCEPTED // Someone accepted and used it
  EXPIRED  // End of day, refunded to giver as credit
}

enum MealGiftAction {
  ACCEPTED      // Recipient applied to their order
  PAID_FORWARD  // Recipient passed to next person
}
